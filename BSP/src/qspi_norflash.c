/**
  ******************************************************************************
  * @file    bsp_qspi_flash.c
  * @author  fire
  * @version V1.0
  * @date    2019-xx-xx
  * @brief   qspi flash 底层应用函数bsp 
  ******************************************************************************
  * @attention
  *
  * 实验平台:野火STM32 H743 开发板
  * 论坛    :http://www.firebbs.cn
  * 淘宝    :http://firestm32.taobao.com
  *
  ******************************************************************************
  */
  
#include "qspi_norflash.h"
#include "quadspi.h"
#include "stdio.h"

//QSPI_HandleTypeDef hqspi;

/**
	void写寄存器
	void读寄存器
	
	void等待busy位
	
	void写使能
	
	void写命令
	void写数据
	void写命令+写数据
	void读数据
	
	void初始化
*/
/**
  * @brief  配置QSPI为内存映射模式
  * @retval QSPI内存状态
  */
uint32_t QSPI_EnableMemoryMappedMode()
{
  QSPI_CommandTypeDef      s_command;
  QSPI_MemoryMappedTypeDef s_mem_mapped_cfg;

  /* 配置读指令 */
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
  s_command.Instruction       = QUAD_INOUT_FAST_READ_CMD_4BYTE1;
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
  s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
//	s_command.Address           = 0x00000020;
  s_command.DataMode          = QSPI_DATA_4_LINES;
  s_command.DummyCycles       = 6;
  s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

  /* 配置内存映射模式 */
  s_mem_mapped_cfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
  s_mem_mapped_cfg.TimeOutPeriod     = 5;

  if (HAL_QSPI_MemoryMapped(&hqspi, &s_command, &s_mem_mapped_cfg) != HAL_OK)
  {
    return QSPI_ERROR;
  }
	
//	/* 传输数据 */
//	if (HAL_QSPI_Transmit(&hqspi, &value,5000) != HAL_OK)
//	{
//		printf("hear5\n");
//		return QSPI_ERROR;
//	}

  return QSPI_OK;
}
/**
  * @brief  设置QSPI存储器为4-byte地址模式
  * @param  无
  * @retval 返回状态
  */
uint8_t QSPI_EnterFourBytesAddress(void)
{
  QSPI_CommandTypeDef s_command;

  /* Initialize the command */
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
  s_command.Instruction       = ENTER_4_BYTE_ADDR_MODE_CMD; //WRITE_STATUS_REG2_CMD
  s_command.AddressMode       = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode          = QSPI_DATA_NONE;
  s_command.DummyCycles       = 0;
  s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

  /* 使能写操作 */
  QSPI_WriteEnable();
  
  /* 传输命令 */
  if (HAL_QSPI_Command(&hqspi, &s_command,5000) != HAL_OK)
  {
    return QSPI_ERROR;
  }

	/* 自动轮询模式等待存储器就绪 */  
	if (QSPI_AutoPollingMemReady(5000) != QSPI_OK)
	{
		return QSPI_ERROR;
	}
	return QSPI_OK;

}
/**
  * @brief  初始化QSPI存储器
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_Init(void)
{
	QSPI_CommandTypeDef s_command;
	uint8_t value = 0X02;
	/* 使能写操作 */
	if (QSPI_WriteEnable() != QSPI_OK)
	{
		return QSPI_ERROR;
	}	
	
	QSPI_FLASH_ReadStatusReg(3);
	
	/* 设置四路使能的状态寄存器，使能四通道IO2和IO3引脚 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = WRITE_STATUS_REG2_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.NbData            = 1;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
	
	/* 配置命令 */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	/* 传输数据 */
	if (HAL_QSPI_Transmit(&hqspi, &value,5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	/* 自动轮询模式等待存储器就绪 */  
	if (QSPI_AutoPollingMemReady(5000) != QSPI_OK)
	{
		return QSPI_ERROR;
	}
	
  /* QSPI memory reset */
  if (QSPI_ResetMemory() != QSPI_OK)
  {
    return QSPI_ERROR;
  }
	
	
//	QSPI_EnterFourBytesAddress();

	
	return QSPI_OK;
}

/**
  * @brief  从QSPI存储器中读取大量数据.
  * @param  pData: 指向要读取的数据的指针
  * @param  ReadAddr: 读取起始地址
  * @param  Size: 要读取的数据大小    
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_Read(uint8_t* pData, uint32_t ReadAddr, uint32_t Size)
{
	QSPI_CommandTypeDef s_command;
  
  if(Size == 0)
  {
    printf("BSP_QSPI_Read Size = 0");
    return QSPI_OK;
  }

	/* 初始化读命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = READ_CMD_4BYTE;
	s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
	s_command.Address           = ReadAddr;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.NbData            = Size;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	/* 配置命令 */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{      
		return QSPI_ERROR;
	}

	/* 接收数据 */
	if (HAL_QSPI_Receive(&hqspi, pData, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	return QSPI_OK;
}
/**
  * @brief  从QSPI存储器中读取大量数据.
  * @param  pData: 指向要读取的数据的指针
  * @param  ReadAddr: 读取起始地址
  * @param  Size: 要读取的数据大小    
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_FastRead(uint8_t* pData, uint32_t ReadAddr, uint32_t Size)
{
	QSPI_CommandTypeDef s_command;

  if(Size == 0)
  {
    printf("BSP_QSPI_FastRead Size = 0");
    return QSPI_OK;
  }
	/* 初始化读命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = 0xeb;
	s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
	s_command.Address           = ReadAddr;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_4_LINES;
	s_command.DummyCycles       = 6;
	s_command.NbData            = Size;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_ONLY_FIRST_CMD;

	/* 配置命令 */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}

	/* 接收数据 */
	if (HAL_QSPI_Receive(&hqspi, pData, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	return QSPI_OK;
}

/**
  * @brief  将大量数据写入QSPI存储器
  * @param  pData: 指向要写入数据的指针
  * @param  WriteAddr: 写起始地址
  * @param  Size: 要写入的数据大小    
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_Write(uint8_t* pData, uint32_t WriteAddr, uint32_t Size)
{
	QSPI_CommandTypeDef s_command;
	uint32_t end_addr, current_size, current_addr;
  
  if(Size == 0)
  {
    printf("BSP_QSPI_Write Size = 0");
    return QSPI_OK;
  }
	
	if(Size > 256)
  {
     Size = 256;
		printf("Error: Flash每次写入数据不能超过256字节！\n");
  }

	/* 初始化程序命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = QUAD_INPUT_PAGE_PROG_CMD_4BYTE;
	s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_4_LINES;
	s_command.DummyCycles       = 0;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
	
	s_command.Address = WriteAddr;
	s_command.NbData  = Size;
	
	/* 写使能 */
	if (QSPI_WriteEnable() != QSPI_OK)
	{
		return QSPI_ERROR;
	}	
	
	/* 发送qspi页编程命令(0x32) */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}	
	
	/* 逐页执行写入 */
	while (Size--)
	{
		/* 传输数据 */
		if (HAL_QSPI_Transmit(&hqspi, pData, 5000) != HAL_OK)
		{
			return QSPI_ERROR;
		}

		pData += 1;
	} 
	
	/* 配置自动轮询模式等待程序结束 */  
	if (QSPI_AutoPollingMemReady(5000) != QSPI_OK)
	{
		return QSPI_ERROR;
	}	
	
	return QSPI_OK;
}

/**
  * @brief  将大量数据写入QSPI存储器
  * @param  pData: 指向要写入数据的指针
  * @param  WriteAddr: 写起始地址
  * @param  Size: 要写入的数据大小    
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_WritePP(uint8_t* pData, uint32_t WriteAddr, uint32_t Size)
{
	QSPI_CommandTypeDef s_command;
	uint32_t end_addr, current_size, current_addr;
  
  if(Size == 0)
  {
    printf("BSP_QSPI_Write Size = 0");
    return QSPI_OK;
  }
	
	if(Size > 256)
  {
     Size = 256;
		printf("Error: Flash每次写入数据不能超过256字节！\n");
  }

	/* 初始化程序命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = QUAD_INPUT_PAGE_PROG_CMD_1BYTE;
	s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_ONLY_FIRST_CMD;
	
	s_command.Address = WriteAddr;
	s_command.NbData  = Size;
	
	/* 写使能 */
	if (QSPI_WriteEnable() != QSPI_OK)
	{
		return QSPI_ERROR;
	}	
	
	/* 发送qspi页编程命令(0x02) */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}	
	
	/* 逐页执行写入 */
	while (Size--)
	{
		/* 传输数据 */
		if (HAL_QSPI_Transmit(&hqspi, pData, 5000) != HAL_OK)
		{
			return QSPI_ERROR;
		}

		pData += 1;
	} 
	
	/* 配置自动轮询模式等待程序结束 */  
	if (QSPI_AutoPollingMemReady(5000) != QSPI_OK)
	{
		return QSPI_ERROR;
	}	
	
	return QSPI_OK;
}

void BSP_QSPI_WriteUnfixedPP(uint8_t* pWriteBuffer, uint32_t WriteAddr, uint32_t WriteLength)
{
	uint32_t PageNumofWirteLength     = WriteLength / W25Q256JV_PAGE_SIZE;            //待写入页数
	uint8_t  NotEnoughNumofPage       = WriteLength % W25Q256JV_PAGE_SIZE;            //不足一页的数量
	uint8_t  WriteAddrPageAlignment   = WriteAddr % W25Q256JV_PAGE_SIZE;              //如果取余为0，则地址页对齐，可以写连续写入256字节
	uint8_t  NotAlignmentNumofPage    = W25Q256JV_PAGE_SIZE - WriteAddrPageAlignment; //地址不对齐部分，最多可以写入的字节数
	
	//写入地址页对齐
	if(WriteAddrPageAlignment == 0)
	{
		//待写入数据不足一页
		if(PageNumofWirteLength == 0)
		{
			BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,WriteLength);
		}
		//待写入数据超过一页
		else
		{
			//先写入整页
			while(PageNumofWirteLength--)
			{
				BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,W25Q256JV_PAGE_SIZE);
				pWriteBuffer += W25Q256JV_PAGE_SIZE;
				WriteAddr    += W25Q256JV_PAGE_SIZE;
			}
			//再写入不足一页的数据
			if(NotEnoughNumofPage > 0)
			{
				BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,NotEnoughNumofPage);
			}
		}
	}
	//写入地址与页不对齐
	else
	{
		//待写入数据不足一页
		if(PageNumofWirteLength == 0)
		{
			//不足一页的数据 <= 地址不对齐部分
			if(NotEnoughNumofPage <= NotAlignmentNumofPage)
			{
				BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,WriteLength);
			}
			//不足一页的数据 > 地址不对齐部分
			else
			{
				//先写地址不对齐部分允许写入的最大长度
				BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,NotAlignmentNumofPage);				
				pWriteBuffer += NotAlignmentNumofPage;
				WriteAddr    += NotAlignmentNumofPage;
				
				//再写没写完的数据
				BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,NotEnoughNumofPage-NotAlignmentNumofPage);
			}
		}
		//待写入数据超过一页
		else
		{
			//先写地址不对齐部分允许写入的最大长度，地址此时对齐了
		  BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,NotAlignmentNumofPage);				
			pWriteBuffer += NotAlignmentNumofPage;
			WriteAddr    += NotAlignmentNumofPage;
			
			//地址对其后，重新计算写入页数与不足一页的数量
			WriteLength           -= NotAlignmentNumofPage;
			PageNumofWirteLength   = WriteLength / W25Q256JV_PAGE_SIZE;            //待写入页数
	    NotEnoughNumofPage     = WriteLength % W25Q256JV_PAGE_SIZE; 
			
			//先写入整页
			while(PageNumofWirteLength--)
			{
				BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,W25Q256JV_PAGE_SIZE);
				pWriteBuffer += W25Q256JV_PAGE_SIZE;
				WriteAddr    += W25Q256JV_PAGE_SIZE;
			}
			//再写入不足一页的数据
			if(NotEnoughNumofPage > 0)
			{
				BSP_QSPI_WritePP(pWriteBuffer,WriteAddr,NotEnoughNumofPage);
			}
		}
	}
}

void BSP_QSPI_WriteUnfixed(uint8_t* pWriteBuffer, uint32_t WriteAddr, uint32_t WriteLength)
{
	uint32_t PageNumofWirteLength     = WriteLength / W25Q256JV_PAGE_SIZE;            //待写入页数
	uint8_t  NotEnoughNumofPage       = WriteLength % W25Q256JV_PAGE_SIZE;            //不足一页的数量
	uint8_t  WriteAddrPageAlignment   = WriteAddr % W25Q256JV_PAGE_SIZE;              //如果取余为0，则地址页对齐，可以写连续写入256字节
	uint8_t  NotAlignmentNumofPage    = W25Q256JV_PAGE_SIZE - WriteAddrPageAlignment; //地址不对齐部分，最多可以写入的字节数
	
	//写入地址页对齐
	if(WriteAddrPageAlignment == 0)
	{
		//待写入数据不足一页
		if(PageNumofWirteLength == 0)
		{
			BSP_QSPI_Write(pWriteBuffer,WriteAddr,WriteLength);
		}
		//待写入数据超过一页
		else
		{
			//先写入整页
			while(PageNumofWirteLength--)
			{
				BSP_QSPI_Write(pWriteBuffer,WriteAddr,W25Q256JV_PAGE_SIZE);
				pWriteBuffer += W25Q256JV_PAGE_SIZE;
				WriteAddr    += W25Q256JV_PAGE_SIZE;
			}
			//再写入不足一页的数据
			if(NotEnoughNumofPage > 0)
			{
				BSP_QSPI_Write(pWriteBuffer,WriteAddr,NotEnoughNumofPage);
			}
		}
	}
	//写入地址与页不对齐
	else
	{
		//待写入数据不足一页
		if(PageNumofWirteLength == 0)
		{
			//不足一页的数据 <= 地址不对齐部分
			if(NotEnoughNumofPage <= NotAlignmentNumofPage)
			{
				BSP_QSPI_Write(pWriteBuffer,WriteAddr,WriteLength);
			}
			//不足一页的数据 > 地址不对齐部分
			else
			{
				//先写地址不对齐部分允许写入的最大长度
				BSP_QSPI_Write(pWriteBuffer,WriteAddr,NotAlignmentNumofPage);				
				pWriteBuffer += NotAlignmentNumofPage;
				WriteAddr    += NotAlignmentNumofPage;
				
				//再写没写完的数据
				BSP_QSPI_Write(pWriteBuffer,WriteAddr,NotEnoughNumofPage-NotAlignmentNumofPage);
			}
		}
		//待写入数据超过一页
		else
		{
			//先写地址不对齐部分允许写入的最大长度，地址此时对齐了
		  BSP_QSPI_Write(pWriteBuffer,WriteAddr,NotAlignmentNumofPage);				
			pWriteBuffer += NotAlignmentNumofPage;
			WriteAddr    += NotAlignmentNumofPage;
			
			//地址对其后，重新计算写入页数与不足一页的数量
			WriteLength           -= NotAlignmentNumofPage;
			PageNumofWirteLength   = WriteLength / W25Q256JV_PAGE_SIZE;            //待写入页数
	    NotEnoughNumofPage     = WriteLength % W25Q256JV_PAGE_SIZE; 
			
			//先写入整页
			while(PageNumofWirteLength--)
			{
				BSP_QSPI_Write(pWriteBuffer,WriteAddr,W25Q256JV_PAGE_SIZE);
				pWriteBuffer += W25Q256JV_PAGE_SIZE;
				WriteAddr    += W25Q256JV_PAGE_SIZE;
			}
			//再写入不足一页的数据
			if(NotEnoughNumofPage > 0)
			{
				BSP_QSPI_Write(pWriteBuffer,WriteAddr,NotEnoughNumofPage);
			}
		}
	}
}

/**
  * @brief  擦除QSPI存储器的指定块 
  * @param  BlockAddress: 需要擦除的块地址  
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_Erase_Block(uint32_t BlockAddress)
{
	QSPI_CommandTypeDef s_command;
	/* 初始化擦除命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = SECTOR_ERASE_CMD_4BYTE;
	s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
	s_command.AddressSize       = QSPI_ADDRESS_24_BITS;
	s_command.Address           = BlockAddress;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_NONE;
	s_command.DummyCycles       = 0;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	/* 启用写操作 */
	if (QSPI_WriteEnable() != QSPI_OK)
	{
		printf("这里");
		return QSPI_ERROR;
	}
  //QSPI_FLASH_Wait_Busy();
	/* 发送命令 */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		printf("这里1");
		return QSPI_ERROR;
	}
  //QSPI_FLASH_Wait_Busy();
	/* 配置自动轮询模式等待擦除结束 */  
	if (QSPI_AutoPollingMemReady(W25Q256JV_SUBSECTOR_ERASE_MAX_TIME) != QSPI_OK)
	{
		printf("这里2");
		return QSPI_ERROR;
	}
  
	return QSPI_OK;
}

/**
  * @brief  擦除整个QSPI存储器
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_Erase_Chip(void)
{
	QSPI_CommandTypeDef s_command;
	/* 初始化擦除命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = CHIP_ERASE_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_NONE;
	s_command.DummyCycles       = 0;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	/* 启用写操作 */
	if (QSPI_WriteEnable() != QSPI_OK)
	{
		return QSPI_ERROR;
	}
	/* 发送命令 */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	} 
	/* 配置自动轮询模式等待擦除结束 */  
	if (QSPI_AutoPollingMemReady(W25Q256JV_BULK_ERASE_MAX_TIME) != QSPI_OK)
	{
		return QSPI_ERROR;
	}
	return QSPI_OK;
}

/**
  * @brief  读取QSPI存储器的当前状态
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_GetStatus(void)
{
	QSPI_CommandTypeDef s_command;
	uint8_t reg;
	/* 初始化读取状态寄存器命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = READ_STATUS_REG1_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.NbData            = 1;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	/* 配置命令 */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	/* 接收数据 */
	if (HAL_QSPI_Receive(&hqspi, &reg, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	} 
	/* 检查寄存器的值 */
	if((reg & W25Q256JV_FSR_BUSY) != 0)
	{
		return QSPI_BUSY;
	}
	else
	{
		return QSPI_OK;
	}
}

/**
  * @brief  返回QSPI存储器的配置
  * @param  pInfo: 在配置结构上的指针  
  * @retval QSPI存储器状态
  */
uint8_t BSP_QSPI_GetInfo(QSPI_Info* pInfo)
{
	/* 配置存储器配置结构 */
	pInfo->FlashSize          = W25Q256JV_FLASH_SIZE;
	pInfo->EraseSectorSize    = W25Q256JV_SUBSECTOR_SIZE;
	pInfo->EraseSectorsNumber = (W25Q256JV_FLASH_SIZE/W25Q256JV_SUBSECTOR_SIZE);
	pInfo->ProgPageSize       = W25Q256JV_PAGE_SIZE;
	pInfo->ProgPagesNumber    = (W25Q256JV_FLASH_SIZE/W25Q256JV_PAGE_SIZE);
	return QSPI_OK;
}

/**
  * @brief  复位QSPI存储器。
  * @param  hqspi: QSPI句柄
  * @retval 无
  */
uint8_t QSPI_ResetMemory()
{
	QSPI_CommandTypeDef s_command;
	/* 初始化复位使能命令 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = RESET_ENABLE_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_NONE;
	s_command.DummyCycles       = 0;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	/* 发送命令 */
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		printf("hear8\n");
		return QSPI_ERROR;
	}

	/* 发送复位存储器命令 */
	s_command.Instruction = RESET_MEMORY_CMD;
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		printf("hear7\n");
		return QSPI_ERROR;
	}

	/* 配置自动轮询模式等待存储器就绪 */  
	if (QSPI_AutoPollingMemReady(5000) != QSPI_OK)
	{
		return QSPI_ERROR;
	}
	return QSPI_OK;
}


/**
  * @brief  发送写入使能，等待它有效.
  * @param  hqspi: QSPI句柄
  * @retval 无
  */
static uint8_t QSPI_WriteEnable()
{
	QSPI_CommandTypeDef     s_command;
	QSPI_AutoPollingTypeDef s_config;
	/* 启用写操作 */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = WRITE_ENABLE_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_NONE;
	s_command.DummyCycles       = 0;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
	
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	
	/* 配置自动轮询模式等待写启用 */  
	s_config.Match           = W25Q256JV_FSR_WREN;
	s_config.Mask            = W25Q256JV_FSR_WREN;
	s_config.MatchMode       = QSPI_MATCH_MODE_AND;
	s_config.StatusBytesSize = 1;
	s_config.Interval        = 0x10;
	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;

	s_command.Instruction    = READ_STATUS_REG1_CMD;
	s_command.DataMode       = QSPI_DATA_1_LINE;
	s_command.NbData         = 1;
	
	if (HAL_QSPI_AutoPolling(&hqspi, &s_command, &s_config, 1000) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	
	
	return QSPI_OK;
}

/**
  * @brief  读取存储器的SR并等待EOP
  * @param  hqspi: QSPI句柄
  * @param  Timeout 超时
  * @retval 无
  */
static uint8_t QSPI_AutoPollingMemReady(uint32_t Timeout)
{
	QSPI_CommandTypeDef     s_command;
	QSPI_AutoPollingTypeDef s_config;
	/* 配置自动轮询模式等待存储器准备就绪 */  
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = READ_STATUS_REG1_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	s_config.Match           = 0x00;
	s_config.Mask            = W25Q256JV_FSR_BUSY;
	s_config.MatchMode       = QSPI_MATCH_MODE_AND;
	s_config.StatusBytesSize = 1;
	s_config.Interval        = 0x10;
	s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;

	if (HAL_QSPI_AutoPolling(&hqspi, &s_command, &s_config, Timeout) != HAL_OK)
	{
		return QSPI_ERROR;
	}
	return QSPI_OK;
}

 /**
  * @brief  读取FLASH ID
  * @param 	无
  * @retval FLASH ID
  */
uint32_t QSPI_FLASH_ReadID(void)
{
	QSPI_CommandTypeDef s_command;
	uint32_t Temp = 0;
	uint8_t pData[3];
	/* 读取JEDEC ID */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = READ_JEDEC_ID_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
	s_command.AddressSize       = QSPI_ADDRESS_32_BITS;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DummyCycles       = 0;
	s_command.NbData            = 3;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}
	if (HAL_QSPI_Receive(&hqspi, pData, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}

	Temp = ( pData[2] | pData[1]<<8 )| ( pData[0]<<16 );

	return Temp;
}

 /**
  * @brief  读取FLASH Device ID
  * @param 	无
  * @retval FLASH Device ID
  */
uint32_t QSPI_FLASH_ReadDeviceID(void)
{  
	QSPI_CommandTypeDef s_command;
	uint32_t Temp = 0;
	uint8_t pData[3];
	/*##-2-读取设备ID测试    ###########################################*/
	/* 读取制造/设备 ID */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	s_command.Instruction       = READ_ID_CMD;
	s_command.AddressMode       = QSPI_ADDRESS_1_LINE;
	s_command.AddressSize       = QSPI_ADDRESS_32_BITS;
	s_command.Address           = 0x000000;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.NbData            = 2;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}
	if (HAL_QSPI_Receive(&hqspi, pData, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}

	Temp = pData[1] |( pData[0]<<8 ) ;

	return Temp;
}

 /**
  * @brief  读取ReadStatusReg
  * @param 	无
  * @retval ReadStatusReg
  */
uint32_t QSPI_FLASH_ReadStatusReg(uint8_t reg)
{  
	QSPI_CommandTypeDef s_command;
	uint32_t Temp = 0;
	uint8_t pData[10];

	/* 读取制造/设备 ID */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	if(reg == 1)
	s_command.Instruction       = READ_STATUS_REG1_CMD;
	else if(reg == 2)
	s_command.Instruction       = READ_STATUS_REG2_CMD;
	else if(reg == 3)
	s_command.Instruction       = READ_STATUS_REG3_CMD;
	
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AddressSize       = QSPI_ADDRESS_32_BITS;
	s_command.Address           = 0x000000;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.NbData            = 1;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
	
	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}
	if (HAL_QSPI_Receive(&hqspi, pData, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}
	
	//单flash时读取的字节数为pData[0]，pData[1]
	//Temp = pData[0] |( pData[1]<<8 ) ;
	
	//双flash时读取的字节数为pData[0]，pData[2]
	//Temp = pData[1] |( pData[0]<<8 ) ;
		Temp = pData[0] ;
	return Temp;
}

 /**
  * @brief  写WriteStatusReg
  * @param 	无
  * @retval ReadStatusReg
  */
uint32_t QSPI_FLASH_WriteStatusReg(uint8_t reg,uint8_t regvalue)
{  
	QSPI_CommandTypeDef s_command;
	
	/* 使能写操作 */
	if (QSPI_WriteEnable() != QSPI_OK)
	{
		return QSPI_ERROR;
	}	
	/* 读取制造/设备 ID */
	s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
	if(reg == 1)
	s_command.Instruction       = WRITE_STATUS_REG1_CMD;
	else if(reg == 2)
	s_command.Instruction       = WRITE_STATUS_REG2_CMD;
	else if(reg == 3)
	s_command.Instruction       = WRITE_STATUS_REG3_CMD;
	
	s_command.AddressMode       = QSPI_ADDRESS_NONE;
	s_command.AddressSize       = QSPI_ADDRESS_8_BITS;
	s_command.Address           = 0x000000;
	s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
	s_command.DataMode          = QSPI_DATA_1_LINE;
	s_command.DummyCycles       = 0;
	s_command.NbData            = 1;
	s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
	s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
	s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

	if (HAL_QSPI_Command(&hqspi, &s_command, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}
	if (HAL_QSPI_Transmit(&hqspi, &regvalue, 5000) != HAL_OK)
	{
		printf("something wrong ....\r\n");
		/* 用户可以在这里添加一些代码来处理这个错误 */
		while(1)
		{
			
		}
	}
	/* 自动轮询模式等待存储器就绪 */  
	if (QSPI_AutoPollingMemReady(W25Q256JV_SUBSECTOR_ERASE_MAX_TIME) != QSPI_OK)
	{
		return QSPI_ERROR;
	}

	return QSPI_OK;
}

//void QSPI_Set_WP_High(void)
//{
//	/*定义一个GPIO_InitTypeDef类型的结构体*/
//	GPIO_InitTypeDef  GPIO_InitStruct;
//	__GPIOF_CLK_ENABLE();
//	/*选择要控制的GPIO引脚*/															   
//	GPIO_InitStruct.Pin = GPIO_PIN_7;	
//	/*设置引脚的输出类型为推挽输出*/
//	GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;  
//	/*设置引脚为上拉模式*/
//	GPIO_InitStruct.Pull  = GPIO_PULLUP;
//	/*设置引脚速率为高速 */   
//	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; 
//	/*调用库函数，使用上面配置的GPIO_InitStructure初始化GPIO*/
//	HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);	
//	
//	HAL_GPIO_WritePin(GPIOF,GPIO_PIN_7,1);
//}
//void QSPI_Set_WP_TO_QSPI_IO(void)
//{
//	/*定义一个GPIO_InitTypeDef类型的结构体*/
//	GPIO_InitTypeDef  GPIO_InitStruct;
//	QSPI_FLASH_BK1_IO2_CLK_ENABLE();

//	//设置引脚
//	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//	GPIO_InitStruct.Pull = GPIO_NOPULL;
//	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
//	/*!< 配置 QSPI_FLASH 引脚: IO2 */
//	GPIO_InitStruct.Pin = QSPI_FLASH_BK1_IO2_PIN;
//	GPIO_InitStruct.Alternate = QSPI_FLASH_BK1_IO2_AF;
//	HAL_GPIO_Init(QSPI_FLASH_BK1_IO2_PORT, &GPIO_InitStruct);
//}

//等待空闲
void QSPI_FLASH_Wait_Busy(void)   
{   
	while((QSPI_FLASH_ReadStatusReg(1)&0x01)==0x01);   // 等待BUSY位清空
}   

/*********************************************END OF FILE**********************/
